################################################################################
#
# RevBayes Test-Script: Testing all available methods of class TraceTree
#
#
# authors: David Cerny
#
################################################################################

# No random seed: if we set the credibleTreeSetSize argument to 1 wherever
# applicable, the output should be deterministic.

# Read in a trace of 6-taxon trees originally provided by Wenjie Zhu (see
# https://github.com/revbayes/revbayes/issues/753)

treetrace = readTreeTrace("data/500_ncd.trees", treetype="clock", burnin=0)

# Extract some useful variables
clade_0 = clade("B", "S")
clade_1 = clade("Hm", "Hp")
clades_to_check = [clade_0, clade_1]

print("###################################################################")
print("# Test .size(), .getBurnin(), .setBurnin(), .getNumberOfSamples() #")
print("###################################################################\n")

print("Total trees in trace: " + treetrace.size(post = FALSE))
print("Initial burnin: " + treetrace.getBurnin())
print("# of post-burnin samples according to .size(): " + treetrace.size(post = TRUE))
print("# of post-burnin samples according to .getNumberSamples(): " + treetrace.getNumberSamples(post = TRUE) + "\n")

print("Since the burnin is 0, the numbers returned by .getNumberSamples()")
print("should be the same regardless of whether the `post` argument is set")
print("to TRUE or FALSE. Are they?")
print( treetrace.getNumberSamples(post = TRUE) == treetrace.getNumberSamples(post = FALSE))
print("")

print("Trying to change burnin to 10% of trace length...\n")
treetrace.setBurnin(0.1)

print("Total trees in trace: " + treetrace.size(post = FALSE))
print("Current burnin: " + treetrace.getBurnin())
print("# of post-burnin samples according to .size(): " + treetrace.size(post = TRUE))
print("# of post-burnin samples according to .getNumberSamples(): " + treetrace.getNumberSamples(post = TRUE) + "\n")

print("Since we now have a nonzero burnin, testing the numbers returned by ")
print(".getNumberSamples() with `post` set to TRUE and FALSE for equality")
print("should yield FALSE:")
print( treetrace.getNumberSamples(post = TRUE) == treetrace.getNumberSamples(post = FALSE))

print("\n###################################")
print("# Test .getTree() and .getTrees() #")
print("###################################\n")

# Tree 5+x should become tree 5 after we have removed the first x trees as burnin
topo_0 = treetrace.getTree(5 + treetrace.getBurnin(), post = FALSE)
topo_1 = treetrace.getTree(5, post = TRUE)
print("Can we extract the same tree using both regular and post-burnin indices?")
print( topo_0 == topo_1 )

# Also test a different way of counting trees and accessing a single tree
topo_2 = treetrace.getTrees()[5]
print("Can we extract the i-th tree using both .getTree(i) and .getTrees()[i]?")
print( topo_0 == topo_2 )
print("Does the .getTrees() method return the number of post-burnin trees only?")
print( treetrace.getTrees().size() == treetrace.getNumberSamples(post = TRUE) )

print("\n#####################################################")
print("# Test .getTopologyFrequency() and .isTreeCovered() #")
print("#####################################################\n")

###### Note that in all methods that have it -- .cladeProbability(),
###### .computeEntropy(), .computePairwiseRFDistances(), .getTopologyFrequency(),
###### .getUniqueClades(), .getUniqueTrees(), .isTreeCovered(),
###### .jointCladeProbability(), and .summarize() -- the `verbose`
###### argument just displays a progress bar. However, even this is only
###### true of the first method we call on a given TraceTree object.
###### For subsequent method calls, we do not get a progress bar even if
###### we explicitly set `verbose=TRUE`.

print("Frequency of trees that are topologically identical to the 5th tree in the trace: " + treetrace.getTopologyFrequency(topo_0, verbose=FALSE))
print("Is this tree part of the 50% credible set?")
print( treetrace.isTreeCovered(topo_0, 0.5, verbose=FALSE) )

###### Note that .isTreeCovered() is broken: it returns FALSE even when ci_size is 1.                                                                 

print("\n###################################################################")
print("# Test .cladeProbability(), .getTMRCA(), .jointCladeProbability() #")
print("###################################################################\n")

print("Frequency of the (B+S) clade: " + treetrace.cladeProbability(clade_0, verbose=FALSE))
print("Joint frequency of the (B+S) and (Hm+Hp) clades: " + treetrace.jointCladeProbability(clades_to_check, verbose=FALSE) + "\n")

print("Crown ages of clade (B+S), calculated only from those trees in which the two form an exclusive clade:\n")
treetrace.getTMRCA(clade_0, strict=TRUE, stem=FALSE) # default
print("")

print("Stem ages of clade (B+S), calculated only from those trees in which the two form an exclusive clade:\n")
treetrace.getTMRCA(clade_0, strict=TRUE, stem=TRUE)
print("")

print("Crown ages of the clade originating with the MRCA of B and S:\n")
treetrace.getTMRCA(clade_0, strict=FALSE, stem=FALSE)
print("")

print("Stem ages of the clade originating with the MRCA of B and S:\n")
treetrace.getTMRCA(clade_0, strict=FALSE, stem=FALSE)
print("")

###### Returning an age of -1 when the taxa in question do not form an exclusive
###### clade is ugly. It means we can't get a meaningful estimate of the clade's
###### age by calling mean() on the result.

###### Also, when calling ?TraceTree.getTMRCA, the description of the argument
###### `strict` says "Return -1 if the clade is non-monophyletic". That makes no
###### sense; clades are monophyletic by definition.

print("When we do not require the group (B+S) to be strictly monophyletic,")
print("do we get as many ages for it as there are post-burnin samples?")
print( treetrace.size(post = TRUE) == treetrace.getTMRCA(clade_0, strict=FALSE).size() )

print("\n#################################################")
print("# Test .getUniqueClades() and .getUniqueTrees() #")
print("#################################################\n")

print("Unique clades with a posterior probability of at least 0.05:")
treetrace.getUniqueClades(0.05, verbose=FALSE)
print("")

###### In both TreeSummary.h (though not TreeSummary.cpp) and more importantly
###### ?TraceTree.getUniqueClades, we say that the first argument of the method
###### sets the credible set size. That's not at all what it does -- it sets
###### the minimum probability a clade has to have to be included.

###### Also, the `nonTrivial` argument is broken!

print("Unique topologies in this trace: " + treetrace.getUniqueTrees(1).size())

print("\n################################################################################")
print("# Test .computeEntropy(), .computePairwiseRFDistances(), .computeTreeLengths() #")
print("################################################################################\n")

tax_num = treetrace.getTree(1).ntips()
print("Entropy of the entire post-burnin sample: " + treetrace.computeEntropy(1, tax_num) + "\n")

###### It makes no sense to require a `num_taxa` argument. The method should
###### automatically extract this variable from the trace.

print("Extract all unique trees, coerce the resulting vector to a new tree")
print("trace, and compute pairwise RF distances between its elements:\n")

unique_topo = treetrace.getUniqueTrees(1)
sub_trace = treeTrace(unique_topo)
sub_trace.computePairwiseRFDistances(1, verbose=FALSE)

print("\nAre we getting the expected number of distances, i.e, n*(n - 1)/2 for n trees?")
print( unique_topo.size() * ( unique_topo.size() - 1 ) / 2 == sub_trace.computePairwiseRFDistances(1, verbose = FALSE).size() )
print("")

###### THIS TEST IS CURRENTLY FAILING.

print("Tree lengths:\n")
treetrace.computeTreeLengths()
print("")

print("Are we calculating tree lengths for the post-burnin sample only?")
print( treetrace.size(post = TRUE) == treetrace.computeTreeLengths().size() )

#######################
# Test .setOutgroup() #
#######################

# There doesn't seem to be a good way to test this method. Ideally, we would
# like it to determine how the summary trees produced by functions such as
# mapTree() will be rooted, but since these actually set their own outgroup
# internally (see https://github.com/revbayes/revbayes/issues/694), calling
# the method on a trace has no observable effect.

print("\n#####################")
print("# Test .summarize() #")
print("#####################\n")

print("Generate a summary of the trace, including all post-burnin trees and")
print("all clades with a posterior probability of at least 0.05:")
treetrace.summarize(1, 0.05)

print("###################")
print("# Test .methods() #")
print("###################\n")

print("Available methods for an object of type " + type(treetrace) + ":\n")
treetrace.methods()

clear()

q()