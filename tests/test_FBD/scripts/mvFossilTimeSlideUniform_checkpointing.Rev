################################################################################
#
# RevBayes Test-Script: Restarting a checkpointed FBD analysis that employs the
#                       mvFossilTimeSlideUniform move to sample tip ages
# 
# authors: Tracy A. Heath, Walker C. Pett, April M. Wright
#
################################################################################

seed(12345)

#######################
# Reading in the Data #
#######################

# Create the full list of taxa (including all fossils and extant species)
taxa <- readTaxonData("data/bears_taxa.tsv")

# Import the molecular sequences
cytb <- readDiscreteCharacterData("data/bears_cytb.nex")

# Import the morphological character matrix
morpho <- readDiscreteCharacterData("data/bears_morphology.nex")

# Add the missing taxa to each data partition
cytb.addMissingTaxa( taxa )
morpho.addMissingTaxa( taxa )

# Helpers
n_taxa <- taxa.size()
n_branches <- 2 * n_taxa - 2

moves = VectorMoves()
monitors = VectorMonitors()

##########################################################################################
# Joint Fossilized Birth-Death Process prior on the topology and fossil occurrence times #
##########################################################################################

# Define exponential priors on the birth rate and death rate
speciation_rate ~ dnExponential(10)
extinction_rate ~ dnExponential(10)

moves.append( mvScale(speciation_rate, lambda=0.01, weight=1) )
moves.append( mvScale(speciation_rate, lambda=0.1,  weight=1) )
moves.append( mvScale(speciation_rate, lambda=1.0,  weight=1) )

moves.append( mvScale(extinction_rate, lambda=0.01, weight=1) )
moves.append( mvScale(extinction_rate, lambda=0.1,  weight=1) )
moves.append( mvScale(extinction_rate, lambda=1,    weight=1) )

# Create deterministic nodes for the diversification and turnover rates so that they can be monitored
diversification := speciation_rate - extinction_rate
turnover := extinction_rate/speciation_rate

# All extant bears are represented in this analysis
rho <- 1.0

# Assume an exponential prior on the rate of sampling fossils (psi)
psi ~ dnExponential(10) 

moves.append( mvScale(psi, lambda=0.01, weight=1) )
moves.append( mvScale(psi, lambda=0.1,  weight=1) )
moves.append( mvScale(psi, lambda=1,    weight=1) )

# Specify a uniform prior on the origin time
origin_time ~ dnUnif(37.2, 55.0)

moves.append( mvSlide(origin_time, delta=0.01, weight=5.0) )
moves.append( mvSlide(origin_time, delta=0.1,  weight=5.0) )
moves.append( mvSlide(origin_time, delta=1,    weight=5.0) )

# Define the tree-prior distribution as the fossilized birth-death process
fbd_dist = dnBDSTP(r=0, origin=origin_time, lambda=speciation_rate, mu=extinction_rate, psi=psi, rho=rho, taxa=taxa)

# Define a clade constraint
clade_ursinae = clade("Melursus_ursinus", "Ursus_arctos", "Ursus_maritimus", 
                      "Helarctos_malayanus", "Ursus_americanus", "Ursus_thibetanus", 
                      "Ursus_abstrusus", "Ursus_spelaeus")

constraints = v(clade_ursinae)
fbd_tree ~ dnConstrainedTopology(fbd_dist, constraints=constraints)

# Specify moves on the tree and node times
moves.append( mvFNPR(fbd_tree, weight=15.0) )
moves.append( mvCollapseExpandFossilBranch(fbd_tree, origin_time, weight=6.0) )
moves.append( mvNodeTimeSlideUniform(fbd_tree, weight=40.0) )
moves.append( mvRootTimeSlideUniform(fbd_tree, origin_time, weight=5.0) )

# Use stratigraphic range data to explicitly sample the fossil occurence times
fossils = fbd_tree.getFossils()
for(i in 1:fossils.size())
{
    t[i] := tmrca( fbd_tree, clade(fossils[i]) )

    a[i] = fossils[i].getMinAge()
    b[i] = fossils[i].getMaxAge()

    F[i] ~ dnUniform(t[i] - b[i], t[i] - a[i])
    F[i].clamp( 0 )
}

# Add a move to sample the fossil times
moves.append( mvFossilTimeSlideUniform(fbd_tree, origin_time, weight=5.0) )

# Monitor the number of sampled ancestors in the FBD-tree 
num_samp_anc := fbd_tree.numSampledAncestors();

# Monitor the age of the extant bears
clade_extant = clade("Ailuropoda_melanoleuca", "Tremarctos_ornatus", "Melursus_ursinus",
                     "Ursus_arctos", "Ursus_maritimus", "Helarctos_malayanus",
                     "Ursus_americanus", "Ursus_thibetanus")
age_extant := tmrca(fbd_tree, clade_extant)

# Monitor the age of a particular fossil
age_Kretzoiarctos_beatrix := tmrca( fbd_tree, clade("Kretzoiarctos_beatrix") )

# Monitor the subtree without fossil taxa for which we do not have morphological or molecular data
pruned_tree := fnPruneTree( fbd_tree, prune=v(taxa[17], taxa[20]) )

############################################################
# Uncorrelated exponential model on molecular branch rates #
############################################################

# The rate along each branch is drawn from an exponential prior
branch_rates_mean ~ dnExponential(10.0)

moves.append( mvScale(branch_rates_mean, lambda=0.01, weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=0.1,  weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=1.0,  weight=1.0) )

# Draw branch rates
for(i in 1:n_branches) {
    branch_rates[i] ~ dnExp(1/branch_rates_mean)
    moves.append( mvScale(branch_rates[i], lambda=1.0,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.1,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.01, weight=1.0) )
}

moves.append( mvVectorScale(branch_rates, lambda=0.01, weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=0.1,  weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=1.0,  weight=4.0) )

#####################################
# GTR+G nucleotide substitution model #
#####################################

# Draw the stationary frequencies from a uniform Dirichlet distribution
sf_hp <- v(1, 1, 1, 1)
sf ~ dnDirichlet(sf_hp)

# Draw the exchangeability rates from a uniform Dirichlet distribution
er_hp <- v(1, 1, 1, 1, 1, 1)
er ~ dnDirichlet(er_hp)

moves.append( mvSimplexElementScale(er, alpha=10.0, weight=5.0) )
moves.append( mvSimplexElementScale(sf, alpha=10.0, weight=5.0) )

# Create the Q-matrix
Q_cytb := fnGTR(er, sf)

# Create a discretized gamma distribution of rate categories
alpha_cytb ~ dnExponential( 1.0 )
rates_cytb := fnDiscretizeGamma( alpha_cytb, alpha_cytb, 4 )

moves.append( mvScale(alpha_cytb, lambda=0.01, weight=1.0) )
moves.append( mvScale(alpha_cytb, lambda=0.1,  weight=1.0) )
moves.append( mvScale(alpha_cytb, lambda=1,    weight=1.0) )

# Create the overall molecular model and clamp it to our observed DNA data
phySeq ~ dnPhyloCTMC(tree=fbd_tree, Q=Q_cytb, siteRates=rates_cytb, branchRates=branch_rates, type="DNA")
phySeq.clamp(cytb)

###########################################
# Binary morphological substitution model #
###########################################

# Create the Q-matrix
Q_morpho := fnJC(2)

# Create a discretized gamma distribution of rate categories
alpha_morpho ~ dnExponential( 1.0 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

moves.append( mvScale(alpha_morpho, lambda=0.01, weight=5.0) )
moves.append( mvScale(alpha_morpho, lambda=0.1,  weight=3.0) )
moves.append( mvScale(alpha_morpho, lambda=1,    weight=1.0) )

# We assume a strict morphological clock rate, drawn from an exponential prior
clock_morpho ~ dnExponential(1.0)

moves.append( mvScale(clock_morpho, lambda=0.01, weight=4.0) )
moves.append( mvScale(clock_morpho, lambda=0.1,  weight=4.0) )
moves.append( mvScale(clock_morpho, lambda=1,    weight=4.0) )

# Create the overall morphological model and clamp it to our observed "standard" data
# We also condition on observing only variable characters
phyMorpho ~ dnPhyloCTMC(tree=fbd_tree, siteRates=rates_morpho, branchRates=clock_morpho, Q=Q_morpho, type="Standard", coding="variable")
phyMorpho.clamp(morpho)

########
# MCMC #
########

# Initialize the model object
mymodel = model(sf)

# Add monitors
monitors.append( mnModel(filename="output/mvFossilTimeSlideUniform_checkpointing.log", printgen=10) )
monitors.append( mnFile(filename="output/mvFossilTimeSlideUniform_checkpointing.trees", printgen=10, pruned_tree) )

# Initialize the MCMC from a checkpoint
mymcmc = mcmc(mymodel, monitors, moves)
mymcmc.initializeFromCheckpoint("data/bears.state")

# Run the MCMC #
mymcmc.run(generations=50)

clear()

q()