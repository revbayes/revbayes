# N             <- args[1]
# N_eff         <- args[2]
# MUT_RATE      <- args[3] * 1.0

# POMO_VERSION  <- args[1]
# POMO_TYPE     <- args[2]
# CODING        <- args[3]
# MAPPING       <- args[4]
# fn_data <- "data/sim_variablel.cf"
# tree <- readTrees( "data/Photinus.tree" )[1]

N             <- 4
N_eff         <- 1000
MUT_RATE      <- 0.0000028 * 1.0
POMO_VERSION  <- "new"
POMO_TYPE     <- "2N"
CODING        <- "all"
MAPPING       <- "Sampled"

fn_data <- "data/three_taxa.cf"
tree <- readTrees( "data/three_taxa.tree" )[1]

# fitness coefficients
phi <- [1.0,1.0]
mu  <- MUT_RATE

"N = " + N

if ( POMO_TYPE != "M2N" ) {
  N_eff <- N
}

"N_eff = " + N_eff

  # rate matrix
if ( POMO_VERSION != "new" ) {
  setOption("outputPrecision",14)
  data <- readPoMoCountFile( countFile=fn_data, virtualPopulationSize=N, format="PoMo")
  Q_PoMo := fnPoMo2N(N, N_eff, [mu,mu], phi, FALSE, TRUE)
} else {
  setOption("outputPrecision",14,FALSE)
  data <- readPoMoCountFile( countFile=fn_data, virtualPopulationSize=N, format="PoMo", samplingCorrection=MAPPING,effectivePopulationSize=N_eff)
  Q_PoMo := fnPoMoKN(2,N, N_eff, [mu,mu], phi)
}

seq ~ dnPhyloCTMC(tree=tree, Q=Q_PoMo, type="PoMo",coding=CODING)
seq.clamp(data)
seq.lnProbability()

q()
